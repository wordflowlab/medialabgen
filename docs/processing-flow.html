<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>影海拾贝 - 核心处理流程可视化</title>
    
    <!-- React 18 and React DOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- React Flow 11 -->
    <script src="https://unpkg.com/reactflow@11.11.3/dist/umd/index.js"></script>
    <link href="https://unpkg.com/reactflow@11.11.3/dist/style.css" rel="stylesheet">
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0a0e27 0%, #151932 100%);
            color: #e1e1e6;
            height: 100vh;
            overflow: hidden;
        }
        
        #root {
            height: 100vh;
            width: 100vw;
            position: relative;
        }
        
        /* 关键修复 - 防止React Flow默认灰色背景 */
        .react-flow__node {
            background: transparent !important;
        }
        
        .react-flow__handle {
            width: 10px;
            height: 10px;
            border: 2px solid #0a0e27;
            transition: all 0.2s;
        }
        
        .react-flow__handle:hover {
            transform: scale(1.3);
        }
        
        .react-flow__edge-path {
            stroke-width: 2.5;
            transition: stroke-width 0.2s;
        }
        
        .react-flow__edge-path:hover {
            stroke-width: 4;
        }
        
        /* 输入节点样式 */
        .input-node {
            background: linear-gradient(135deg, rgba(79, 195, 247, 0.15), rgba(79, 195, 247, 0.05));
            backdrop-filter: blur(10px);
            border: 2px solid #4FC3F7;
            border-radius: 16px;
            padding: 16px;
            min-width: 200px;
            box-shadow: 0 8px 32px rgba(79, 195, 247, 0.3);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .input-node:hover {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 12px 40px rgba(79, 195, 247, 0.4);
        }
        
        /* 处理节点样式 */
        .process-node {
            background: linear-gradient(135deg, rgba(129, 199, 132, 0.15), rgba(129, 199, 132, 0.05));
            backdrop-filter: blur(10px);
            border: 2px solid #81C784;
            border-radius: 12px;
            padding: 14px;
            min-width: 180px;
            box-shadow: 0 8px 32px rgba(129, 199, 132, 0.3);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .process-node.processing {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { 
                box-shadow: 0 8px 32px rgba(129, 199, 132, 0.3);
                border-color: #81C784;
            }
            50% { 
                box-shadow: 0 8px 40px rgba(129, 199, 132, 0.6);
                border-color: #4CAF50;
            }
        }
        
        /* AI节点样式 */
        .ai-node {
            background: linear-gradient(135deg, rgba(156, 39, 176, 0.15), rgba(156, 39, 176, 0.05));
            backdrop-filter: blur(10px);
            border: 2px solid #9C27B0;
            border-radius: 12px;
            padding: 14px;
            min-width: 200px;
            box-shadow: 0 8px 32px rgba(156, 39, 176, 0.3);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .ai-node:hover {
            transform: translateY(-2px) scale(1.02);
            box-shadow: 0 12px 40px rgba(156, 39, 176, 0.4);
        }
        
        /* 输出节点样式 */
        .output-node {
            background: linear-gradient(135deg, rgba(255, 183, 77, 0.15), rgba(255, 183, 77, 0.05));
            backdrop-filter: blur(10px);
            border: 2px solid #FFB74D;
            border-radius: 12px;
            padding: 14px;
            min-width: 160px;
            box-shadow: 0 8px 32px rgba(255, 183, 77, 0.3);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .output-node.completed {
            border-color: #4CAF50;
            box-shadow: 0 8px 32px rgba(76, 175, 80, 0.3);
        }
        
        /* 分组节点样式 */
        .group-node {
            background: rgba(255, 255, 255, 0.02);
            border: 2px dashed rgba(255, 255, 255, 0.2);
            border-radius: 20px;
            padding: 20px;
            min-width: 300px;
            min-height: 200px;
        }
        
        .group-title {
            font-size: 14px;
            font-weight: 600;
            color: #ffffff;
            opacity: 0.8;
            margin-bottom: 12px;
            text-transform: uppercase;
            letter-spacing: 1px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        /* 节点内容样式 */
        .node-header {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }
        
        .node-icon {
            font-size: 20px;
        }
        
        .node-title {
            font-size: 13px;
            font-weight: 600;
            color: #ffffff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        
        .node-status {
            margin-left: auto;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            animation: blink 2s infinite;
        }
        
        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .status-ready { background: #FFC107; }
        .status-processing { background: #2196F3; }
        .status-completed { background: #4CAF50; }
        .status-error { background: #FF5252; }
        
        .node-content {
            font-size: 11px;
            color: #ffffff;
            opacity: 0.9;
            margin-top: 8px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .node-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-top: 10px;
        }
        
        .metric-item {
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(5px);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .metric-label {
            color: #e1e1e6;
            opacity: 0.8;
            margin-bottom: 2px;
            font-size: 10px;
        }
        
        .metric-value {
            font-weight: 600;
            font-size: 12px;
            color: #ffffff;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        /* 进度条样式 */
        .progress-bar {
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4FC3F7, #2196F3);
            border-radius: 2px;
            transition: width 0.3s ease;
        }
        
        /* 动画边样式 */
        @keyframes flow {
            0% { stroke-dashoffset: 0; }
            100% { stroke-dashoffset: -20; }
        }
        
        .animated-edge {
            stroke-dasharray: 5 5;
            animation: flow 1s linear infinite;
        }
        
        /* 控制面板 */
        .control-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(10, 14, 39, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px;
            z-index: 100;
            min-width: 200px;
            transition: transform 0.3s ease;
        }
        
        .control-panel.collapsed {
            transform: translateX(180px);
        }
        
        .panel-toggle {
            position: absolute;
            left: -30px;
            top: 50%;
            transform: translateY(-50%);
            width: 30px;
            height: 60px;
            background: rgba(10, 14, 39, 0.95);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-right: none;
            border-radius: 8px 0 0 8px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #4FC3F7;
            font-size: 12px;
        }
        
        .control-button {
            display: block;
            width: 100%;
            padding: 8px 12px;
            margin: 8px 0;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            color: #e1e1e6;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
        }
        
        .control-button:hover {
            background: rgba(79, 195, 247, 0.2);
            border-color: #4FC3F7;
            transform: translateX(-2px);
        }
        
        .control-button.active {
            background: rgba(79, 195, 247, 0.3);
            border-color: #4FC3F7;
        }
        
        /* 流程状态面板 */
        .status-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(10, 14, 39, 0.95);
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 16px;
            z-index: 100;
            min-width: 300px;
        }
        
        .status-title {
            font-size: 13px;
            font-weight: 600;
            margin-bottom: 12px;
            opacity: 0.8;
        }
        
        .status-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
        }
        
        .status-item {
            text-align: center;
        }
        
        .status-value {
            font-size: 18px;
            font-weight: 600;
            color: #4FC3F7;
        }
        
        .status-label {
            font-size: 10px;
            opacity: 0.5;
            margin-top: 4px;
        }
        
        /* FAB按钮 */
        .fab {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4FC3F7, #2196F3);
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(79, 195, 247, 0.4);
            transition: all 0.3s;
            z-index: 200;
        }
        
        .fab:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 30px rgba(79, 195, 247, 0.6);
        }
        
        /* 通知样式 */
        .notification {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.95), rgba(76, 175, 80, 0.85));
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 13px;
            z-index: 1000;
            animation: slideDown 0.3s ease;
            box-shadow: 0 4px 20px rgba(76, 175, 80, 0.4);
        }
        
        @keyframes slideDown {
            from {
                transform: translateX(-50%) translateY(-100%);
                opacity: 0;
            }
            to {
                transform: translateX(-50%) translateY(0);
                opacity: 1;
            }
        }
        
        /* 响应式详情 */
        .detail-minimal { display: none; }
        .detail-basic { display: block; }
        .detail-full { display: block; }
    </style>
</head>
<body>
    <div id="root"></div>
    
    <script type="text/babel">
        const { useState, useCallback, useMemo, useEffect, useRef } = React;
        
        // React Flow 导入 - 关键防错
        const ReactFlowComponent = window.ReactFlow.default || window.ReactFlow.ReactFlow;
        const { 
            Background, 
            Controls, 
            MiniMap,
            Handle,
            Position,
            MarkerType,
            getBezierPath,
            getSmoothStepPath,
            getStraightPath,
            useNodesState, 
            useEdgesState,
            useReactFlow,
            ReactFlowProvider,
            addEdge,
            applyNodeChanges,
            applyEdgeChanges
        } = window.ReactFlow;
        
        // ==================== 自定义节点组件 ====================
        
        // 输入节点 - 视频URL输入
        const InputNode = ({ data, selected }) => {
            const [url, setUrl] = useState('');
            const [status, setStatus] = useState('ready');
            
            return (
                <div className={`input-node ${selected ? 'selected' : ''}`}>
                    <div className="node-header">
                        <span className="node-icon">🔗</span>
                        <span className="node-title">{data.label}</span>
                        <div className={`node-status status-${status}`} />
                    </div>
                    <div className="node-content">
                        <input 
                            type="text" 
                            placeholder="粘贴视频URL..."
                            value={url}
                            onChange={(e) => setUrl(e.target.value)}
                            style={{
                                width: '100%',
                                padding: '6px',
                                background: 'rgba(0, 0, 0, 0.4)',
                                border: '1px solid rgba(255, 255, 255, 0.3)',
                                borderRadius: '4px',
                                color: '#ffffff',
                                fontSize: '11px'
                            }}
                        />
                        <div style={{ marginTop: '8px', fontSize: '10px', color: '#ffffff', opacity: 0.8 }}>
                            支持: YouTube / TED / B站 / Vimeo
                        </div>
                    </div>
                    <Handle type="source" position={Position.Right} style={{ background: '#4FC3F7' }} />
                </div>
            );
        };
        
        // 处理节点 - 视频下载/音频提取等
        const ProcessNode = ({ data, selected }) => {
            const [progress, setProgress] = useState(0);
            const [status, setStatus] = useState('ready');
            const [metrics, setMetrics] = useState({
                time: '0s',
                size: '0MB'
            });
            
            useEffect(() => {
                if (data.processing) {
                    const interval = setInterval(() => {
                        setProgress(prev => {
                            if (prev >= 100) {
                                setStatus('completed');
                                return 100;
                            }
                            return prev + Math.random() * 10;
                        });
                        setMetrics({
                            time: Math.floor(Math.random() * 10 + 5) + 's',
                            size: Math.floor(Math.random() * 50 + 10) + 'MB'
                        });
                    }, 1000);
                    setStatus('processing');
                    return () => clearInterval(interval);
                }
            }, [data.processing]);
            
            return (
                <div className={`process-node ${status === 'processing' ? 'processing' : ''}`}>
                    <Handle type="target" position={Position.Left} style={{ background: '#81C784' }} />
                    
                    <div className="node-header">
                        <span className="node-icon">{data.icon}</span>
                        <span className="node-title">{data.label}</span>
                        <div className={`node-status status-${status}`} />
                    </div>
                    
                    {data.description && (
                        <div className="node-content">{data.description}</div>
                    )}
                    
                    {status === 'processing' && (
                        <div className="progress-bar">
                            <div className="progress-fill" style={{ width: `${progress}%` }} />
                        </div>
                    )}
                    
                    {(status === 'processing' || status === 'completed') && (
                        <div className="node-metrics">
                            <div className="metric-item">
                                <div className="metric-label">时间</div>
                                <div className="metric-value">{metrics.time}</div>
                            </div>
                            <div className="metric-item">
                                <div className="metric-label">大小</div>
                                <div className="metric-value">{metrics.size}</div>
                            </div>
                        </div>
                    )}
                    
                    <Handle type="source" position={Position.Right} style={{ background: '#81C784' }} />
                </div>
            );
        };
        
        // AI节点 - Whisper/Claude/GPT处理
        const AINode = ({ data, selected }) => {
            const [processing, setProcessing] = useState(false);
            const [tokens, setTokens] = useState(0);
            const [accuracy, setAccuracy] = useState('0%');
            
            useEffect(() => {
                if (data.active) {
                    setProcessing(true);
                    const interval = setInterval(() => {
                        setTokens(prev => prev + Math.floor(Math.random() * 100));
                        setAccuracy(Math.floor(Math.random() * 5 + 95) + '%');
                    }, 2000);
                    return () => clearInterval(interval);
                }
            }, [data.active]);
            
            return (
                <div className={`ai-node ${selected ? 'selected' : ''}`}>
                    <Handle type="target" position={Position.Left} style={{ background: '#9C27B0' }} />
                    
                    <div className="node-header">
                        <span className="node-icon">{data.icon}</span>
                        <span className="node-title">{data.label}</span>
                        <div className={`node-status status-${processing ? 'processing' : 'ready'}`} />
                    </div>
                    
                    <div style={{
                        display: 'inline-block',
                        padding: '2px 8px',
                        background: 'rgba(0, 0, 0, 0.4)',
                        border: '1px solid rgba(156, 39, 176, 0.5)',
                        borderRadius: '4px',
                        fontSize: '10px',
                        color: '#ffffff',
                        marginTop: '6px'
                    }}>
                        {data.model || 'Claude 4 Opus'}
                    </div>
                    
                    {processing && (
                        <div className="node-metrics" style={{ marginTop: '10px' }}>
                            <div className="metric-item">
                                <div className="metric-label">Tokens</div>
                                <div className="metric-value">{tokens}</div>
                            </div>
                            <div className="metric-item">
                                <div className="metric-label">准确率</div>
                                <div className="metric-value">{accuracy}</div>
                            </div>
                        </div>
                    )}
                    
                    <Handle type="source" position={Position.Right} style={{ background: '#9C27B0' }} />
                    {data.multiOutput && (
                        <>
                            <Handle type="source" position={Position.Bottom} id="output2" style={{ background: '#9C27B0', left: '30%' }} />
                            <Handle type="source" position={Position.Bottom} id="output3" style={{ background: '#9C27B0', left: '70%' }} />
                        </>
                    )}
                </div>
            );
        };
        
        // 输出节点 - 文章/PPT/思维导图
        const OutputNode = ({ data, selected }) => {
            const [generated, setGenerated] = useState(false);
            const [wordCount, setWordCount] = useState(0);
            
            useEffect(() => {
                if (data.generate) {
                    setTimeout(() => {
                        setGenerated(true);
                        setWordCount(Math.floor(Math.random() * 1000 + 500));
                    }, 2000);
                }
            }, [data.generate]);
            
            return (
                <div className={`output-node ${generated ? 'completed' : ''}`}>
                    <Handle type="target" position={Position.Left} style={{ background: '#FFB74D' }} />
                    
                    <div className="node-header">
                        <span className="node-icon">{data.icon}</span>
                        <span className="node-title">{data.label}</span>
                        <div className={`node-status status-${generated ? 'completed' : 'ready'}`} />
                    </div>
                    
                    {data.format && (
                        <div className="node-content">
                            格式: {data.format}
                        </div>
                    )}
                    
                    {generated && (
                        <div style={{ marginTop: '8px', fontSize: '11px' }}>
                            <div style={{ color: '#4CAF50', textShadow: '0 1px 2px rgba(0, 0, 0, 0.5)' }}>✓ 已生成</div>
                            <div style={{ color: '#ffffff', opacity: 0.8 }}>{wordCount} 字</div>
                        </div>
                    )}
                    
                    <Handle type="source" position={Position.Right} style={{ background: '#FFB74D' }} />
                </div>
            );
        };
        
        // 分组节点 - 用于标识处理阶段
        const GroupNode = ({ data }) => {
            return (
                <div className="group-node">
                    <div className="group-title">{data.label}</div>
                </div>
            );
        };
        
        // ==================== 自定义边组件 ====================
        
        // 数据流动画边
        const AnimatedEdge = ({
            id,
            sourceX,
            sourceY,
            targetX,
            targetY,
            sourcePosition,
            targetPosition,
            data,
            markerEnd,
        }) => {
            const [edgePath, labelX, labelY] = getBezierPath({
                sourceX,
                sourceY,
                sourcePosition,
                targetX,
                targetY,
                targetPosition,
            });
            
            return (
                <>
                    <path
                        id={id}
                        className="react-flow__edge-path animated-edge"
                        d={edgePath}
                        markerEnd={markerEnd}
                        style={{
                            stroke: data?.color || '#4FC3F7',
                            strokeWidth: 2,
                        }}
                    />
                    {data?.label && (
                        <text>
                            <textPath
                                href={`#${id}`}
                                style={{ fontSize: '10px', fill: '#e1e1e6' }}
                                startOffset="50%"
                                textAnchor="middle"
                            >
                                {data.label}
                            </textPath>
                        </text>
                    )}
                </>
            );
        };
        
        // 指标边
        const MetricEdge = ({
            id,
            sourceX,
            sourceY,
            targetX,
            targetY,
            sourcePosition,
            targetPosition,
            data,
            markerEnd,
        }) => {
            const [edgePath, labelX, labelY] = getSmoothStepPath({
                sourceX,
                sourceY,
                sourcePosition,
                targetX,
                targetY,
                targetPosition,
                borderRadius: 10,
            });
            
            return (
                <>
                    <path
                        id={id}
                        className="react-flow__edge-path"
                        d={edgePath}
                        markerEnd={markerEnd}
                        style={{
                            stroke: data?.color || '#81C784',
                            strokeWidth: 2,
                        }}
                    />
                    <foreignObject
                        width={100}
                        height={40}
                        x={labelX - 50}
                        y={labelY - 20}
                    >
                        <div style={{
                            background: 'rgba(10, 14, 39, 0.95)',
                            border: '1px solid rgba(255, 255, 255, 0.1)',
                            borderRadius: '6px',
                            padding: '4px 8px',
                            fontSize: '10px',
                            color: '#e1e1e6',
                            textAlign: 'center'
                        }}>
                            <div>{data?.metric1 || '延迟: 100ms'}</div>
                            <div style={{ opacity: 0.6 }}>{data?.metric2 || '带宽: 10MB/s'}</div>
                        </div>
                    </foreignObject>
                </>
            );
        };
        
        // 节点类型映射
        const nodeTypes = {
            input: InputNode,
            process: ProcessNode,
            ai: AINode,
            output: OutputNode,
            group: GroupNode,
        };
        
        // 边类型映射
        const edgeTypes = {
            animated: AnimatedEdge,
            metric: MetricEdge,
        };
        
        // ==================== 主应用组件 ====================
        
        function ProcessingFlow() {
            const reactFlowWrapper = useRef(null);
            const { project, fitView, getNodes, getEdges, setNodes, setEdges, getZoom, setViewport } = useReactFlow();
            const [nodes, , onNodesChange] = useNodesState([]);
            const [edges, , onEdgesChange] = useEdgesState([]);
            const [controlPanelOpen, setControlPanelOpen] = useState(true);
            const [notification, setNotification] = useState(null);
            const [processStatus, setProcessStatus] = useState('idle');
            const [stats, setStats] = useState({
                totalTime: 0,
                processedVideos: 0,
                generatedContent: 0,
                apiCalls: 0
            });
            
            // 初始化处理流程节点
            useEffect(() => {
                const viewportWidth = window.innerWidth;
                const viewportHeight = window.innerHeight;
                
                const initialNodes = [
                    // 阶段分组背景
                    {
                        id: 'group-input',
                        type: 'group',
                        position: { x: 50, y: 100 },
                        data: { label: '输入阶段' },
                        style: { width: 250, height: 400, zIndex: -1 }
                    },
                    {
                        id: 'group-process',
                        type: 'group',
                        position: { x: 350, y: 100 },
                        data: { label: '处理阶段' },
                        style: { width: 500, height: 400, zIndex: -1 }
                    },
                    {
                        id: 'group-ai',
                        type: 'group',
                        position: { x: 900, y: 100 },
                        data: { label: 'AI分析阶段' },
                        style: { width: 400, height: 400, zIndex: -1 }
                    },
                    {
                        id: 'group-output',
                        type: 'group',
                        position: { x: 1350, y: 100 },
                        data: { label: '输出阶段' },
                        style: { width: 350, height: 400, zIndex: -1 }
                    },
                    
                    // 输入节点
                    {
                        id: 'url-input',
                        type: 'input',
                        position: { x: 100, y: 250 },
                        data: { 
                            label: '视频URL输入',
                            icon: '🔗'
                        }
                    },
                    
                    // 处理节点
                    {
                        id: 'url-parser',
                        type: 'process',
                        position: { x: 400, y: 200 },
                        data: { 
                            label: 'URL解析',
                            icon: '🔍',
                            description: '识别平台和视频ID',
                            processing: false
                        }
                    },
                    {
                        id: 'video-download',
                        type: 'process',
                        position: { x: 600, y: 200 },
                        data: { 
                            label: '视频下载',
                            icon: '📥',
                            description: 'yt-dlp下载器',
                            processing: false
                        }
                    },
                    {
                        id: 'audio-extract',
                        type: 'process',
                        position: { x: 400, y: 350 },
                        data: { 
                            label: '音频提取',
                            icon: '🎵',
                            description: 'FFmpeg处理',
                            processing: false
                        }
                    },
                    {
                        id: 'subtitle-extract',
                        type: 'process',
                        position: { x: 600, y: 350 },
                        data: { 
                            label: '字幕提取',
                            icon: '📝',
                            description: '自动/手动字幕',
                            processing: false
                        }
                    },
                    
                    // AI节点
                    {
                        id: 'whisper-asr',
                        type: 'ai',
                        position: { x: 950, y: 200 },
                        data: { 
                            label: 'Whisper ASR',
                            icon: '🎤',
                            model: 'Whisper Large V3',
                            active: false
                        }
                    },
                    {
                        id: 'claude-analysis',
                        type: 'ai',
                        position: { x: 1150, y: 200 },
                        data: { 
                            label: 'Claude分析',
                            icon: '🤖',
                            model: 'Claude 4 Opus',
                            active: false,
                            multiOutput: true
                        }
                    },
                    {
                        id: 'content-optimizer',
                        type: 'ai',
                        position: { x: 1050, y: 350 },
                        data: { 
                            label: '内容优化',
                            icon: '✨',
                            model: 'ChatGPT 5',
                            active: false
                        }
                    },
                    
                    // 输出节点
                    {
                        id: 'article-output',
                        type: 'output',
                        position: { x: 1400, y: 180 },
                        data: { 
                            label: '文章生成',
                            icon: '📄',
                            format: 'Markdown',
                            generate: false
                        }
                    },
                    {
                        id: 'ppt-output',
                        type: 'output',
                        position: { x: 1550, y: 250 },
                        data: { 
                            label: 'PPT生成',
                            icon: '📊',
                            format: 'PPTX',
                            generate: false
                        }
                    },
                    {
                        id: 'mindmap-output',
                        type: 'output',
                        position: { x: 1400, y: 320 },
                        data: { 
                            label: '思维导图',
                            icon: '🧠',
                            format: 'XMind',
                            generate: false
                        }
                    },
                    {
                        id: 'qa-output',
                        type: 'output',
                        position: { x: 1550, y: 390 },
                        data: { 
                            label: '问答系统',
                            icon: '💬',
                            format: 'Interactive',
                            generate: false
                        }
                    }
                ];
                
                const initialEdges = [
                    // 输入到处理
                    {
                        id: 'e1',
                        source: 'url-input',
                        target: 'url-parser',
                        type: 'animated',
                        animated: true,
                        data: { label: 'URL', color: '#4FC3F7' }
                    },
                    {
                        id: 'e2',
                        source: 'url-parser',
                        target: 'video-download',
                        type: 'metric',
                        data: { 
                            color: '#81C784',
                            metric1: '解析: 50ms',
                            metric2: '成功率: 99%'
                        }
                    },
                    
                    // 并行处理
                    {
                        id: 'e3',
                        source: 'video-download',
                        target: 'audio-extract',
                        type: 'animated',
                        animated: true,
                        data: { label: '视频流', color: '#81C784' }
                    },
                    {
                        id: 'e4',
                        source: 'video-download',
                        target: 'subtitle-extract',
                        type: 'animated',
                        animated: true,
                        data: { label: '字幕流', color: '#81C784' }
                    },
                    
                    // 处理到AI
                    {
                        id: 'e5',
                        source: 'audio-extract',
                        target: 'whisper-asr',
                        type: 'metric',
                        data: { 
                            color: '#9C27B0',
                            metric1: '音频: 128kbps',
                            metric2: '时长: 14:23'
                        }
                    },
                    {
                        id: 'e6',
                        source: 'subtitle-extract',
                        target: 'whisper-asr',
                        style: { strokeDasharray: '5 5', stroke: '#9C27B0' }
                    },
                    {
                        id: 'e7',
                        source: 'whisper-asr',
                        target: 'claude-analysis',
                        type: 'animated',
                        animated: true,
                        data: { label: '转写文本', color: '#9C27B0' }
                    },
                    {
                        id: 'e8',
                        source: 'claude-analysis',
                        target: 'content-optimizer',
                        data: { label: '初稿', color: '#9C27B0' }
                    },
                    
                    // AI到输出
                    {
                        id: 'e9',
                        source: 'claude-analysis',
                        target: 'article-output',
                        type: 'animated',
                        animated: true,
                        data: { color: '#FFB74D' }
                    },
                    {
                        id: 'e10',
                        source: 'claude-analysis',
                        sourceHandle: 'output2',
                        target: 'ppt-output',
                        type: 'animated',
                        animated: true,
                        data: { color: '#FFB74D' }
                    },
                    {
                        id: 'e11',
                        source: 'claude-analysis',
                        sourceHandle: 'output3',
                        target: 'mindmap-output',
                        type: 'animated',
                        animated: true,
                        data: { color: '#FFB74D' }
                    },
                    {
                        id: 'e12',
                        source: 'content-optimizer',
                        target: 'qa-output',
                        type: 'animated',
                        animated: true,
                        data: { color: '#FFB74D' }
                    }
                ];
                
                setNodes(initialNodes);
                setEdges(initialEdges);
                
                // 初始适应视图
                setTimeout(() => fitView({ padding: 0.1 }), 100);
            }, []);
            
            // 模拟处理流程
            const startProcessing = useCallback(() => {
                setProcessStatus('processing');
                showNotification('开始处理视频...');
                
                // 模拟各阶段处理
                const stages = [
                    { nodeId: 'url-parser', delay: 500 },
                    { nodeId: 'video-download', delay: 2000 },
                    { nodeId: 'audio-extract', delay: 1500 },
                    { nodeId: 'subtitle-extract', delay: 1000 },
                    { nodeId: 'whisper-asr', delay: 3000 },
                    { nodeId: 'claude-analysis', delay: 2500 },
                    { nodeId: 'content-optimizer', delay: 1500 },
                    { nodeId: 'article-output', delay: 1000 },
                    { nodeId: 'ppt-output', delay: 1000 },
                    { nodeId: 'mindmap-output', delay: 1000 },
                    { nodeId: 'qa-output', delay: 1000 }
                ];
                
                let totalDelay = 0;
                stages.forEach(stage => {
                    setTimeout(() => {
                        setNodes(nodes => nodes.map(node => {
                            if (node.id === stage.nodeId) {
                                return {
                                    ...node,
                                    data: {
                                        ...node.data,
                                        processing: true,
                                        active: true,
                                        generate: true
                                    }
                                };
                            }
                            return node;
                        }));
                    }, totalDelay);
                    totalDelay += stage.delay;
                });
                
                // 完成处理
                setTimeout(() => {
                    setProcessStatus('completed');
                    showNotification('处理完成！所有内容已生成');
                    setStats(prev => ({
                        totalTime: prev.totalTime + 15,
                        processedVideos: prev.processedVideos + 1,
                        generatedContent: prev.generatedContent + 4,
                        apiCalls: prev.apiCalls + 7
                    }));
                }, totalDelay + 1000);
            }, []);
            
            // 重置流程
            const resetProcess = useCallback(() => {
                setProcessStatus('idle');
                setNodes(nodes => nodes.map(node => ({
                    ...node,
                    data: {
                        ...node.data,
                        processing: false,
                        active: false,
                        generate: false
                    }
                })));
                showNotification('流程已重置');
            }, []);
            
            // 显示通知
            const showNotification = (message) => {
                setNotification(message);
                setTimeout(() => setNotification(null), 2000);
            };
            
            // 键盘快捷键
            useEffect(() => {
                const handleKeyPress = (e) => {
                    if (e.target.tagName === 'INPUT') return;
                    
                    switch(e.key.toLowerCase()) {
                        case 's':
                            if (processStatus === 'idle') startProcessing();
                            break;
                        case 'r':
                            resetProcess();
                            break;
                        case 'h':
                            setControlPanelOpen(prev => !prev);
                            break;
                        case ' ':
                            e.preventDefault();
                            fitView({ padding: 0.1, duration: 800 });
                            break;
                    }
                };
                
                document.addEventListener('keydown', handleKeyPress);
                return () => document.removeEventListener('keydown', handleKeyPress);
            }, [processStatus, startProcessing, resetProcess]);
            
            // 自动布局
            const autoLayout = useCallback(() => {
                const nodes = getNodes();
                const updatedNodes = [...nodes];
                
                // 按类型分组
                const groups = {
                    input: [],
                    process: [],
                    ai: [],
                    output: [],
                    group: []
                };
                
                updatedNodes.forEach(node => {
                    groups[node.type]?.push(node);
                });
                
                // 重新排列
                let xOffset = 100;
                Object.entries(groups).forEach(([type, typeNodes]) => {
                    if (type === 'group') return;
                    
                    typeNodes.forEach((node, index) => {
                        node.position = {
                            x: xOffset,
                            y: 150 + index * 120
                        };
                    });
                    xOffset += 300;
                });
                
                setNodes(updatedNodes);
                setTimeout(() => fitView({ padding: 0.1, duration: 800 }), 100);
                showNotification('布局已优化');
            }, [getNodes]);
            
            // 连接处理
            const onConnect = useCallback((params) => {
                setEdges((eds) => addEdge({ ...params, type: 'animated', animated: true }, eds));
                showNotification('连接已创建');
            }, []);
            
            // 节点点击
            const onNodeClick = useCallback((event, node) => {
                if (node.type !== 'group') {
                    showNotification(`查看 ${node.data.label} 详情`);
                }
            }, []);
            
            // 拖放处理
            const onDragOver = useCallback((event) => {
                event.preventDefault();
                event.dataTransfer.dropEffect = 'move';
            }, []);
            
            const onDrop = useCallback((event) => {
                event.preventDefault();
                
                const reactFlowBounds = reactFlowWrapper.current.getBoundingClientRect();
                const type = event.dataTransfer.getData('application/reactflow');
                
                if (typeof type === 'undefined' || !type) {
                    return;
                }
                
                const position = project({
                    x: event.clientX - reactFlowBounds.left,
                    y: event.clientY - reactFlowBounds.top,
                });
                
                const newNode = {
                    id: `${type}_${Date.now()}`,
                    type,
                    position,
                    data: getNodeData(type),
                };
                
                setNodes((nds) => nds.concat(newNode));
                showNotification('节点已添加');
            }, [project]);
            
            // 获取节点默认数据
            const getNodeData = (type) => {
                const dataMap = {
                    input: { label: '新输入', icon: '📥' },
                    process: { label: '新处理', icon: '⚙️', description: '处理描述' },
                    ai: { label: '新AI节点', icon: '🤖', model: 'Claude 4 Opus' },
                    output: { label: '新输出', icon: '📤', format: 'Unknown' }
                };
                return dataMap[type] || { label: '新节点' };
            };
            
            return (
                <div style={{ width: '100vw', height: '100vh' }} ref={reactFlowWrapper}>
                    {/* 控制面板 */}
                    <div className={`control-panel ${controlPanelOpen ? '' : 'collapsed'}`}>
                        <div className="panel-toggle" onClick={() => setControlPanelOpen(!controlPanelOpen)}>
                            {controlPanelOpen ? '▶' : '◀'}
                        </div>
                        {controlPanelOpen && (
                            <>
                                <div style={{ fontSize: '13px', fontWeight: 600, marginBottom: '12px' }}>
                                    流程控制
                                </div>
                                <button 
                                    className={`control-button ${processStatus === 'processing' ? 'active' : ''}`}
                                    onClick={startProcessing}
                                    disabled={processStatus !== 'idle'}
                                >
                                    {processStatus === 'idle' ? '▶ 开始处理' : 
                                     processStatus === 'processing' ? '⏳ 处理中...' : 
                                     '✓ 已完成'}
                                </button>
                                <button className="control-button" onClick={resetProcess}>
                                    🔄 重置流程
                                </button>
                                <button className="control-button" onClick={autoLayout}>
                                    📐 自动布局
                                </button>
                                <button className="control-button" onClick={() => fitView({ padding: 0.1, duration: 800 })}>
                                    🎯 适应视图
                                </button>
                                
                                <div style={{ marginTop: '16px', fontSize: '11px', opacity: 0.6 }}>
                                    <div>快捷键:</div>
                                    <div>S - 开始处理</div>
                                    <div>R - 重置流程</div>
                                    <div>H - 隐藏面板</div>
                                    <div>空格 - 适应视图</div>
                                </div>
                            </>
                        )}
                    </div>
                    
                    {/* 状态面板 */}
                    <div className="status-panel">
                        <div className="status-title">处理统计</div>
                        <div className="status-grid">
                            <div className="status-item">
                                <div className="status-value">{stats.totalTime}s</div>
                                <div className="status-label">总时间</div>
                            </div>
                            <div className="status-item">
                                <div className="status-value">{stats.processedVideos}</div>
                                <div className="status-label">视频数</div>
                            </div>
                            <div className="status-item">
                                <div className="status-value">{stats.generatedContent}</div>
                                <div className="status-label">生成内容</div>
                            </div>
                            <div className="status-item">
                                <div className="status-value">{stats.apiCalls}</div>
                                <div className="status-label">API调用</div>
                            </div>
                        </div>
                        <div style={{ marginTop: '12px', fontSize: '11px', opacity: 0.6 }}>
                            状态: <span style={{ color: 
                                processStatus === 'idle' ? '#FFC107' : 
                                processStatus === 'processing' ? '#2196F3' : '#4CAF50' 
                            }}>
                                {processStatus === 'idle' ? '空闲' : 
                                 processStatus === 'processing' ? '处理中' : '已完成'}
                            </span>
                        </div>
                    </div>
                    
                    {/* FAB按钮 */}
                    <button className="fab" onClick={startProcessing} disabled={processStatus !== 'idle'}>
                        {processStatus === 'idle' ? '▶' : 
                         processStatus === 'processing' ? '⏳' : '✓'}
                    </button>
                    
                    {/* React Flow 主体 */}
                    <ReactFlowComponent
                        nodes={nodes}
                        edges={edges}
                        onNodesChange={onNodesChange}
                        onEdgesChange={onEdgesChange}
                        onConnect={onConnect}
                        onNodeClick={onNodeClick}
                        onDrop={onDrop}
                        onDragOver={onDragOver}
                        nodeTypes={nodeTypes}
                        edgeTypes={edgeTypes}
                        fitView
                        attributionPosition="bottom-left"
                    >
                        <Background variant="dots" gap={20} size={1} color="rgba(255,255,255,0.02)" />
                        <Controls position="bottom-right" />
                        <MiniMap 
                            nodeColor={(node) => {
                                const colorMap = {
                                    input: '#4FC3F7',
                                    process: '#81C784',
                                    ai: '#9C27B0',
                                    output: '#FFB74D',
                                    group: 'rgba(255,255,255,0.05)'
                                };
                                return colorMap[node.type] || '#64B5F6';
                            }}
                            style={{
                                backgroundColor: 'rgba(10, 14, 39, 0.9)',
                                border: '1px solid rgba(255, 255, 255, 0.1)'
                            }}
                            position="top-left"
                        />
                    </ReactFlowComponent>
                    
                    {/* 通知 */}
                    {notification && (
                        <div className="notification">
                            {notification}
                        </div>
                    )}
                </div>
            );
        }
        
        // 应用包装器
        function App() {
            return (
                <ReactFlowProvider>
                    <ProcessingFlow />
                </ReactFlowProvider>
            );
        }
        
        // 渲染应用
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>